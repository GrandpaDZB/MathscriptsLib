# 粒子群算法PSO(Particle Swarm Optimization)

## 1 原理

设关于x的实数映射f，任务目标是寻找最优x使得f(x)最大/最小，这里不妨设任务目标是最小化f(x)。建立N个随机粒子寻找最优解，有
$$
x_i=[x_{i1},\cdots,x_{in}],i\in\{1,\cdots,N\} \\
x^*=arg_xminf(x)
$$
定义每个粒子的局部最优解P_i，意义是所有迭代中粒子i产生的局部最优解，定义全局最优解，意义是所有迭代中的所有粒子中产生的最优解
$$
P_i:=x_i^*=arg_{x_i}minf(x_i), \text{for } x_i \text{in all iteration}\\
P_g:=x_{tmp}^*=arg_xminf(x), \text{for x in all iteration}
$$
依据局部最优和全局最优，可以建立粒子x的迭代关系，每次迭代粒子朝向全局最优和局部最优的方向运动。总体上依旧是朝向全局最优运动，但是运动过程中有可能发现新的全局最优而修改运动趋势，仍然有收敛到局部最优的风险。
$$
v_{i+1}=wv_{i}+c_1(P_i-x_i)+c_2(P_g-x_i) \\
x_{i+1}=x_i+\sigma(v_{i+1})
$$

- w为惯性因子，可以调整粒子的剧烈程度
- c为权重因子，调节全局最优和局部最优对粒子的影响程度
- sigma为速度限制映射，可以限制速度的范围，也可以是一个缩放因子

当达到最大迭代次数或者粒子群几乎收敛时，就可以终止迭代。

## 2 使用方法

```python
from PSO import PSO

model = PSO(
    # 输入向量维度
	dim = dim,
    # 目标函数，默认进行函数最小优化，所以需要适当调整函数形式满足优化目标。target_func应该是一个输入向量到实数的映射
    target_func = target_func,
    # 约束函数，默认不存在。约束函数应该是输入向量到布尔值的映射，True代表输入向量满足约束，False代表不满足约束
    restrict_func = None,
    # 粒子数量
    N = 40,
    # 惯性因子
    w = 0.5,
    # 局部最优偏向因子
    c1 = 0.25,
    # 全局最优偏向因子
    c2 = 0.25,
    # 随机比例与随机偏置，用于粒子的初始位置生成，粒子初始位置表示为random(-1,1)*random_scale+random_bias。值得注意的是在有约束情况下，初始点会无限循环随机数直到所有初始位置均满足约束，因此设计随机参数时应该使得粒子能够在满足约束的情况下尽可能广地分布
    random_scale = 1,
    random_bias = 0,
)

model.run(
    # 最大迭代次数
	iter = 1000,
    # 速度约束sigma函数类型，可以选择scale，interval，func
    sigma = 'scale',
    # scale下的放缩比率
    scale = 1.0,
    # interval下的限制区间，会将每个维度限制在interval中
    interval = (0,1),
    # 自定义约束函数，应该是向量到向量的映射
    func = None
)

# 运行model.run()后就会进行迭代，会输出迭代次数、粒子群方差与函数最小值，观察到粒子群方差足够小且函数最小值几乎不变时即可提前结束迭代。
# 值得注意的是粒子群算法有很多可调参数，对于非线性性强的函数，这些参数可能会对收敛结果产生明显影响。

# 全局最优向量
model.P_g 
# 局部最优向量
model.P_i
# 粒子群向量
model.x
```

经过足够好的设计，粒子群算法能够解决非常多的优化问题。

例如背包问题，输入向量可以设定为n维向量，用hard_sigmoid函数作用后就可以表示拿去哪些物品，优化目标函数是价格的负值，约束是重量小于某一值